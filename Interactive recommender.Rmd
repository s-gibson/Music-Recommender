---
title: "Interactive recommender"
output: html_notebook
---

One goal (if not the only goal) of a music recommendation engine is to create a program that allows people to input their musical preferences, and through a recommendation algorithm, output a set of music that said person might like.  My recommendation program "Music Recommendation Simulation_v1" (https://github.com/edsp2017/edsp17proj-s-gibson/blob/master/Music%20Recommendation%20Simulation_v1.Rmd) is a simulation that recommends music to users of last.fm's music streaming platform. It is somewhat difficult to evaluate how well the recommendation simulation I have created works, because much of the music that is listened to by users in the dataset and therefore much of the music recommended by the recommender is music that I am not familiar with.  So it is hard for me to evaluate how "similar" recommendations are to the listening habits of the sample users in the dataset.

This program can be thought of as a "beta test" of sorts.  My goal is to create a survey document that will allow survey-takers to input their musical preferences, from which I can create a recommendation list.

First, load appropriate packages and data.
```{r}
library(recommenderlab)
```

```{r}
load("large data/Lastfm_data.RData")
```

The save.image code should only be used if you have created a new training utility matrix through a simulation that is different from the below simulation (i.e. different subset of artists/users, different number of users in matrix).  The process of creating a new utility matrix is quite time inefficient, so saving a created training utility matrix can allow for quick recall of the matrix instead of having to recreate the matrix from scratch.  If you would like to save a different utitlity matrix than the one created through the code below, please rename the file from the file name below, in order to not overwrite my pre-existing data.
```{r}
#save.image("~/Documents/NYU/APSTA 2017/EDSP_v2/large data/Interactive.RData")
```

Examine the 0.05th quantiles of the number of unique artists listened to by users.  This information can be helpful in subsetting users that should be used in the training utility matrix.
```{r}
quantile(User.plays$N.artists, seq(0, 1, .05), na.rm = T)
```

User's with a more diverse listening history should allow for better recommendations (less sparsity in utility matrix).  Let's make recommendations off of the listening history of users who are in the top 20% in terms of number of unique artists.  If you would like to allow for a larger or smaller subset of users, feel free to change the minium number of unique artists, but don't save/overwrite the altered script.
```{r}
User.plays.50 <- User.plays[which(User.plays$N.artists >= 40),]
```

Similarly to how we have eliminated users with rather specific musical preference (as inidicated by a low number of unique artists listened to), It is valuable to eliminate artists who have a narrow listener following (as indicated by a low number of unique listeners).  Let's examine the 0.05th quantiles of Artist.plays$N.users to get a feel the user listening base of many artists.
```{r}
quantile(Artist.plays$N.users, seq(0.9, 1, .01))
```

Let's only consider artists who are in the top 4% by number of unique users (160+ unique listeners, as a arbitrarily round number).  This should cut down on the number of recommendations of niche/specific artists.  This number can be changed moving forward, but for the sake of developing a functional algorithm, let's stick to artists who have a somewhat broad following.  This still allows for close to 10,000 artists, so it's not an overly restrictive library of artists.
```{r}
Artist.plays.100 <- Artist.plays[which(Artist.plays$N.users >= 60),]
```

Similarly to to "Music Recommendation Simulation_v1.Rmd", we must create a data sample from which to train the recommender.  One modification to this sample is that it should include users who are randomly sampled from "User.plays.50" AND only artists who appear in "Artist.plays.10".
```{r}
set.seed(04072017)
N_samp <- 1000
samp.users <- User.plays.50$User[sample(c(1:length(User.plays.50$User)), N_samp , replace = F)]
samp.dat <- Lastfm[which(Lastfm$usersha1 %in% samp.users & Lastfm$artname %in% unique(Artist.plays.100$Artist)),]
```

Let's see how many unique artists there are in our sample of N users
```{r}
print(paste("Number of unique artists in a sample of", N_samp,"users:", 
        length(unique(samp.dat$artname))))
```

As in "Music Recommendation Simulation_v1", we must create a utility matrix of users' musical preferences.  The rows of the matrix are each of the unique users in our sample, the columns are each of the unique artists in our sample.  The values of each cell are the number of listens by user[i] of artist[j].  This matrix is sparse, as users don't listen to most of the different artists, and artists aren't listened to by most of the users.
```{r}
samp.Utility <- matrix(data = NA, nrow = length(unique(samp.dat$usersha1)),
                       ncol = length(unique(samp.dat$artname)))
rownames(samp.Utility) <- unique(samp.dat$usersha1)
colnames(samp.Utility) <- unique(samp.dat$artname)

# fill in utility matrix for training.
for (i in 1:nrow(samp.dat)) {
  samp.Utility[which(rownames(samp.Utility) == samp.dat$usersha1[i]), which(colnames(samp.Utility) == samp.dat$artname[i])] <- samp.dat$plays[i]
}
rm(i)
```

The code below exports a list of unique artists in "samp.dat" to an Excel file.  I had to do some manipuation of the list in order to create a spreadsheet which allows users to type out their favoirte artists and how many times they might "play" said artist in a theoretical replication of last.fm playcount data.
```{r}
write.csv(unique(samp.dat$artname), file = "~/Documents/NYU/APSTA 2017/EDSP_v2/Interactive/input_master.csv")
```

The code below reads back in a completed version of someones "musical preference" spreadsheet, which I will use as the test set for the recommender.  I have asked people to identify their sheet using the format "input_ABC", where ABC is their initials.  In the example below my name is Stewart Alexander Gibson, thus my input musical preference spreadsheet is titled "input_SAG.csv".
```{r}
id <- "SAG"
file.name <- paste("~/Documents/NYU/APSTA 2017/EDSP_v2/Interactive/input_", id,".csv", sep = "")
input.dat <- read.csv(file.name)[,c(1,2)]
```

We now must turn "input.dat" into a utility matrix (of the same dimensions & colnames as "samp.Utility") for the input user.  This matrix will be used as the test data for the recommendation function.
```{r}
Test.Utility <- matrix(data = NA, nrow = 1,
                       ncol = length(unique(samp.dat$artname)))
colnames(Test.Utility) <- colnames(samp.Utility)

# Fill in Test.Utility matrix
rownames(Test.Utility) <- id
  for (i in 1:nrow(input.dat)) {
    Test.Utility[which(colnames(Test.Utility) == input.dat$Artist[i])] <- input.dat$Count[i]
  }
rm(i)
```


Convert the test and train utility matrices to the form "realRatingMatrix", run recommendation model.  The number of recommendations that are in the output can be modified by setting "N_recs".
```{r}
Train.Affinity <- as(samp.Utility,"realRatingMatrix")
Test.Affinity <- as(Test.Utility, "realRatingMatrix")
Rec.model <- Recommender(data = Train.Affinity, method = "UBCF", param=list(normalize = "Z-score",method="Cosine",nn=10))
```

```{r}
N_recs <- 30
recommended.items <- predict(Rec.model, Test.Affinity, n = N_recs)
User.playlist <- input.dat 
User.recs <- as(recommended.items,"list")
User.playlist
data.frame(rnk = c(1:N_recs), User.recs$SAG)
```

