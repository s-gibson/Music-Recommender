---
title: "Interactive recommender"
output: html_notebook
---

One goal (if not the only goal) of a music recommendation engine is to create a program that allows people to input their musical preferences, and through a recommendation algorithm, output a set of music that said person might like.  My recommendation program "Music Recommendation Simulation_v1" (https://github.com/edsp2017/edsp17proj-s-gibson/blob/master/Music%20Recommendation%20Simulation_v1.Rmd) is a simulation that recommends music to users of last.fm's music streaming platform. It is somewhat difficult to evaluate how well the recommendation simulation I have created works, because much of the music that is listened to by users in the dataset and therefore much of the music recommended by the recommender is music that I am not familiar with.  So it is hard for me to evaluate how "similar" recommendations are to the listening habits of the sample users in the dataset.

This program can be thought of as a "beta test" of sorts.  My goal is to create a survey document that will allow survey-takers to input their musical preferences, from which I can create a recommendation list.

First, load appropriate packages and data.
```{r}
require(recommenderlab)
```

```{r}
load("large-rep/Interactive.RData")
```

[[IMPORTANT]]
If you wish simply to run the recommendation model based on the pre-existing training data/utility matrix that exists in the above file, proceed directly to Line 75.

The save.image code should only be used if you have created a new training utility matrix through a simulation that is different from the below simulation (i.e. different subset of artists/users, different number of users in matrix).  The process of creating a new utility matrix is quite time inefficient, so saving a created training utility matrix can allow for quick recall of the matrix instead of having to recreate the matrix from scratch.  If you would like to save a different utitlity matrix than the one created through the code below, please rename the file from the file name below, in order to not overwrite my pre-existing data.
```{r}
#save.image("large data/Interactive.RData")
```

Examine the 0.05th quantiles of the number of unique artists listened to by users.  This information can be helpful in subsetting users that should be used in the training utility matrix.
```{r}
quantile(User.plays$N.artists, seq(0, 1, .05), na.rm = T)
```

User's with a more diverse listening history should allow for better recommendations (less sparsity in utility matrix).  Let's make recommendations off of the listening history of users who are in the top 20% in terms of number of unique artists.  If you would like to allow for a larger or smaller subset of users, feel free to change the minium number of unique artists, but don't save/overwrite the altered script.
```{r}
User.plays.50 <- User.plays[which(User.plays$N.artists >= 40),]
```

Similarly to how we have eliminated users with rather specific musical preference (as inidicated by a low number of unique artists listened to), It is valuable to eliminate artists who have a narrow listener following (as indicated by a low number of unique listeners).  Let's examine the 0.05th quantiles of Artist.plays$N.users to get a feel the user listening base of many artists.
```{r}
quantile(Artist.plays$N.users, seq(0.9, 1, .01))
```

Let's only consider artists who are in the top 4% by number of unique users (160+ unique listeners, as a arbitrarily round number).  This should cut down on the number of recommendations of niche/specific artists.  This number can be changed moving forward, but for the sake of developing a functional algorithm, let's stick to artists who have a somewhat broad following.  This still allows for close to 10,000 artists, so it's not an overly restrictive library of artists.
```{r}
Artist.plays.100 <- Artist.plays[which(Artist.plays$N.users >= 60),]
```

Similarly to to "Music Recommendation Simulation_v1.Rmd", we must create a data sample from which to train the recommender.  One modification to this sample is that it should include users who are randomly sampled from "User.plays.50" AND only artists who appear in "Artist.plays.10".
```{r}
set.seed(04072017)
N_samp <- 1000
samp.users <- User.plays.50$User[sample(c(1:length(User.plays.50$User)), N_samp , replace = F)]
samp.dat <- Lastfm[which(Lastfm$usersha1 %in% samp.users & Lastfm$artname %in% unique(Artist.plays.100$Artist)),]
```

Let's see how many unique artists there are in our sample of N users
```{r}
print(paste("Number of unique artists in a sample of", N_samp,"users:", 
        length(unique(samp.dat$artname))))
```

As in "Music Recommendation Simulation_v1", we must create a utility matrix of users' musical preferences.  The rows of the matrix are each of the unique users in our sample, the columns are each of the unique artists in our sample.  The values of each cell are the number of listens by user[i] of artist[j].  This matrix is sparse, as users don't listen to most of the different artists, and artists aren't listened to by most of the users.
```{r}
samp.Utility <- matrix(data = NA, nrow = length(unique(samp.dat$usersha1)),
                       ncol = length(unique(samp.dat$artname)))
rownames(samp.Utility) <- unique(samp.dat$usersha1)
colnames(samp.Utility) <- unique(samp.dat$artname)

# fill in utility matrix for training.
for (i in 1:nrow(samp.dat)) {
  samp.Utility[which(rownames(samp.Utility) == samp.dat$usersha1[i]), which(colnames(samp.Utility) == samp.dat$artname[i])] <- samp.dat$plays[i]
}
rm(i)
```

[[BEGIN HERE IF USING PRE-EXISTING TRAINING SET/UTILITY MATRIX]]

The goal of this code is to allow users to "interact" with the recommendation algorithm.  That is, allow users to create a "mock" listening history for themselves, and see which artists the algorithm recommends.  In the code below, users can input artists that they like, and assign a hypothetical play count to each artist (the more users like an artist, the more "plays" they should assign to the artist).  In the code chunk below, store the names of the artists that you like in the object "test.artists" and the playcount associated with each artist in "test.plays".  Keep in mind that the order of "test.artists" should correspond to the order of "test.plays".  In the example, the user listens to Michael Jackson 125 times, The Beatles 80 times, and Kanye West 230 times.

Note that all artist names in the data are lower case.  So "Michael Jackson" needs to be stored as "michael jackson".  Also, the spelling of artists must be exact.  The code will not recognize "micheal jackson" becasuse the "a" and "e" are transposed.  The code is also picky with some formatting details.  For example, "&" vs. "and": "bob marley & the wailers" is recognized, but not "bob marley and the wailers".  Also, the use of commas used before "&" in lists: "crosby, stills & nash" is recognized, but not "crosby, stills, & nash".
```{r}
# example: test.artists <- c("michael jackson", "the beatles", "kanye west")
#          test.plays <- c(125, 80, 230)

test.artists <- c("outkast", "a tribe called quest", "kanye west", "mos def", "mf doom", "sly & the family stone", "war", "funkadelic", "marvin gaye", "curtis mayfield","bob marley & the wailers", "jimmy cliff", "black uhuru", "roy ayers ubiquity", "john coltrane", "crosby, stills & nash", "grateful dead", "jimi hendrix", "pink floyd", "santana")
test.plays <- c(90, 80, 65, 60, 80, 75, 85, 80, 50, 45, 85, 50, 45, 55, 35, 30, 100, 95, 45, 50)
```

The code below first checks to make sure that number of artist names matches the number of plays.  If they do not match, the user should go back and adjust the previous chunk so that the number of artists and playcounts are equal.The code below also checks to make sure that the program recognizes the input artist names (mostly to help check to make sure artists' names are spelled correctly).  The output is a dataframe of the artist names, their corrosponding play count, and whether or not the artist name was recognized in 3 different subsets: the sample data ("$Recognized.samp.dat"), the list of artists with 100+ unique listeners ("$Recognized.Artist.plays.100"), and the entire Lastfm artist library ("$Recognized.Lastfm").  If an artist is listed as "FALSE" (meaning they weren't recognized) for all 3 subsets, then the artist name is most likely mispelled.  If an artist is recognized by only Lastfm, then the artist didn't have enough unique listeners to be included in the sample.  If the artist is recognized in all subsets but the sample data, this means that the artist has enough unique listeners, but wasn't listened to by any users in the random sample.  You can adjust the set.seed or the number of users in the sample in attempt to collect a sample that includes the unrecognized artist.  For any unrecognized artists, go back to the previous chunk to correct potential spelling errors, or change the set.seed or number of users in the random sample.
```{r}
if (length(test.artists) == length(test.plays)) {
  test.df <- data.frame(artname = test.artists, playcount = test.plays)
  for(i in c(1:length(test.artists))) {
    test.df$Recognized.samp.dat[i] <- test.df$artname[i] %in% samp.dat$artname
    test.df$Recognized.Artist.plays.100[i] <- test.df$artname[i] %in% Artist.plays.100
    test.df$Recognized.Lastfm[i] <- test.df$artname[i] %in% Lastfm$artname
  }
  test.df
  
} else {print(paste("length(test.artists) = ", length(test.artists), ", length(test.plays) = ", length(test.plays), ": Lengths must match, adjust test.artists/test.plays in previous chunk", sep = ""))}
```

We now must turn "test.df" into a utility matrix (of the same dimensions & colnames as "samp.Utility") for the input user.  This matrix will be used as the test data for the recommendation function, outputting a list of recommended artists.  Enter an id (name, initials, etc) for identifying the input user
```{r}
id <- "SAG"
Test.Utility <- matrix(data = NA, nrow = 1,
                       ncol = length(unique(samp.dat$artname)))
colnames(Test.Utility) <- colnames(samp.Utility)

# Fill in Test.Utility matrix
rownames(Test.Utility) <- id
  for (i in 1:nrow(test.df)) {
    Test.Utility[which(colnames(Test.Utility) == test.df$artname[i])] <- test.df$playcount[i]
  }
rm(i)
```


Convert the test and train utility matrices to the form "realRatingMatrix", and train the recommendation model using the utility matrix of the sample users' listening history.
```{r}
Train.Affinity <- as(samp.Utility,"realRatingMatrix")
Test.Affinity <- as(Test.Utility, "realRatingMatrix")
Rec.model <- Recommender(data = Train.Affinity, method = "UBCF", param=list(normalize = "Z-score",method="Cosine",nn=10))
```

Create a list of recommended artists for the test user using the recommendation model.  The number of recommended artists can be changed through the "N_recs" object.  The output will be the "test.df" from earlier (ordered by playcount) and a list of the recommended artists in order of recommendation.
```{r}
N_recs <- 30
recommended.items <- predict(Rec.model, Test.Affinity, n = N_recs)
User.recs <- as(recommended.items,"list")
test.df[order(test.df$playcount, decreasing = T),c(1:3)]
data.frame(rnk = c(1:N_recs), User.recs[1])
```

